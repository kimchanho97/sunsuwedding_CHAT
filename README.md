# 순수웨딩 2.0

> 순수웨딩 채팅 서비스

### 목차

1. [프로젝트 소개](#-프로젝트-소개)
2. [시연 영상](#-시연-영상)
3. [메시지 처리 아키텍처](#%EF%B8%8F-메시지-처리-아키텍처)
4. [데이터 저장소 관리 전략](#-데이터-저장소-관리-전략)
5. [시스템 구성도](#%EF%B8%8F-시스템-구성도)
6. [프로젝트 구조](#-프로젝트-구조)

<br>

## 🚀 프로젝트 소개

순수웨딩 채팅 서비스는 STOMP 프로토콜과 Kafka 기반의 이벤트 스트리밍을 통해 **확장 가능하고 안정적인 실시간 메시지 전송**을 구현하였으며,  
**데이터 특성에 맞는 삼중 저장소 아키텍처**를 통해 실시간 응답성과 데이터 영구 보존을 모두 확보했습니다.

- **STOMP**: 실시간 양방향 통신 구현
- **Kafka**: 안정적인 메시지 브로커, 비동기 이벤트 처리
- **Redis**: 사용자 세션, 접속 상태, 읽음 상태 등 빈번히 변경되는 메타데이터 고속 처리
- **MongoDB**: 유연한 스키마로 채팅 메시지 영구 저장 및 효율적인 조회
- **관계형 DB**: 채팅방, 참여자 정보 등 구조화된 데이터 영구 저장 및 트랜잭션 관리

<br>

### 🗓 개발 기간

2025.03 ~ 2025.04

<br>

### 🔗 링크 모음

- **서비스 배포 주소**: [https://sunsu-wedding.shop](https://sunsu-wedding.shop/)
- **프론트엔드 레포지토리**: [순수웨딩 프론트엔드 레포지토리 바로가기](https://github.com/kimchanho97/sunsuwedding_FE)
- **백엔드 API 서버 레포지토리**: [순수웨딩 메인 API 서버 레포지토리 바로가기](https://github.com/kimchanho97/sunsuwedding_BE)
- **프로젝트 문서(Notion)**: [순수웨딩 프로젝트 문서 바로가기](https://kimchanho.notion.site/2-0-1a0a1b1b0041809f8f31fa9314b10a34)

> **현재 서비스는 배포되어 접속 가능한 상태이며,**  
> **프로젝트의 모든 상세 내용은 아래 문서에서 확인할 수 있습니다.**

<br>

## 🎥 시연 영상

#### ⚡️ 주요 기능

- 텍스트 및 이미지 실시간 전송
- 메시지 읽음 상태 동기화
- 사용자 온라인/오프라인 상태 표시
- 최근 메시지 기준 채팅방 목록 정렬
- 읽지 않은 메시지 수 표시

![Image](https://github.com/user-attachments/assets/7b804bca-c3da-4618-8d49-89464160a0b2)

<br>
<br>

## ✉️ 메시지 처리 아키텍처

### 📌 유니캐스트 기반 메시지 전송 아키텍처

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/f86a693b-1c3d-40e1-838c-a7a36d75e678" />

채팅 시스템은 확장성과 성능 최적화를 위해 유니캐스트 방식의 메시지 전송 구조를 채택했습니다.

#### 핵심 설계: 독립 메시지 전송 레이어

- **책임 분리**: 채팅 서버와 메시지 전송 로직이 독립된 서버로 분리
- **중앙화된 의존성**: 메시지 전송 서버만이 채팅 서버들과의 연결 관리
- **단방향 의존성**: 채팅 서버는 Kafka 브로커에만 의존하여 결합도 최소화
- **위치 기반 라우팅**: Redis에 저장된 사용자별 서버 위치 정보로 정확한 메시지 전달

#### 확장성 확보

- **스타형 토폴로지**: 채팅 서버 간 직접 연결 없이 중앙 집중식 구조 유지
- **간소화된 인프라**: 새 서버 추가 시 복잡한 네트워크 설정 변경 불필요
- **비대칭 스케일링**: 채팅 서버와 메시지 전송 서버의 인스턴스 수를 독립적으로 조정 가능

#### 메시지 전송 프로세스

1. 클라이언트 메시지 → 채팅방 참여자 조회 → Kafka 이벤트 발행
2. 메시지 전송 서버에서 이벤트 소비
3. Redis에서 대상 사용자의 서버 위치 조회
4. 해당 서버로만 메시지 전달

브로드캐스트 방식과 달리 유니캐스트는 필요한 서버에만 메시지를 전달하여 네트워크 트래픽과 서버 부하를 최소화합니다.

> **참고**: 현재는 인프라 관리 효율성을 고려해 별도 메시지 전송 서버 대신 채팅 서버 내부에 컨슈머 로직을 통합 구현했습니다.

<br>

### 📌 메시지 처리 파이프라인

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/f0f31eb6-677c-4c47-8605-91b43ca1111d" />

메시지 처리의 각 단계를 독립적인 이벤트로 분리하여 시스템의 확장성과 안정성을 확보했습니다:

1. **메시지 수신 및 요청 이벤트 발행**: 클라이언트 메시지 → `chat-message` 토픽 이벤트 발행
2. **영구 저장 처리**: 메시지 시퀀스 할당 → MongoDB 저장 → `chat-message-saved` 토픽 이벤트 발행
3. **후속 병렬 처리**:
    - 읽음 상태 동기화: 온라인 사용자의 읽음 상태 업데이트
    - 메시지 전달: 온라인 사용자 서버로 유니캐스트 메시지 전송
    - 채팅방 정렬: 참여자별 채팅방 목록 정렬 업데이트

이 비동기 파이프라인 구조는 각 단계의 독립적 확장을 가능하게 하며, 메시지 처리 성능을 최적화합니다.

<br>

### 📌 메시지 전달 신뢰성 보장

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/39cfc226-3e1e-4e4c-bfe6-e4b5ea16d892" />

채팅 서비스는 데이터 일관성과 메시지 유실 방지를 위해 두 가지 수준의 신뢰성을 구현했습니다.

#### 기본 신뢰성 보장 (At-least-once)

채팅 서비스의 모든 이벤트 처리는 **최소 한 번 전달(at-least-once delivery)** 방식으로 설계되어 메시지 유실을 방지합니다.

- **프로듀서 측 구현**
    - `acks=all` 설정으로 모든 레플리카 확인 후 응답
    - 멱등 프로듀서(`enable.idempotence=true`) 설정으로 중복 전송 방지
- **컨슈머 측 구현**
    - 명시적 수동 확인(Manual Acknowledgment) 방식 채택
    - 처리 완료 후에만 오프셋 커밋하여 메시지 유실 방지
    - 멱등적 처리 로직으로 중복 처리 방지

#### 중요 경로의 정확히 한 번 전달 (Exactly-once)

핵심 메시지 저장 경로(`chat-message` → `chat-message-saved`)에서는 **정확히 한 번 전달(exactly-once delivery)을** 보장하여 데이터 일관성을 유지합니다.

- **Kafka 트랜잭션 처리**
    - 트랜잭션 프로듀서 및 컨슈머 사용
    - 이벤트 발행과 오프셋 커밋의 원자성 보장
    - 격리 수준 `read_committed` 설정으로 커밋된 메시지만 소비
- **MongoDB 멱등성**
    - MongoDB에서 메시지 ID(`_id`) 기반 upsert 연산으로 멱등성 보장
    - `findAndModify` 연산으로 저장과 조회를 단일 원자적 작업으로 처리

이러한 설계는 메시지 처리의 신뢰성을 보장하면서도, 추가 서비스 연동 시 확장성을 고려한 구조입니다.

<br>

## 💾 데이터 저장소 관리 전략

### 1️⃣ Redis 캐싱 전략 (고성능 실시간 처리)

채팅 서비스의 실시간 데이터는 Redis에 우선 저장하여 지연 시간을 최소화하고 처리량을 극대화합니다.

#### 캐싱 원칙

- **Write-Through 캐싱**: 중요 데이터는 Redis 저장 후 이벤트 발행으로 영구 저장 트리거
- **Read-Aside 캐싱**: 자주 조회되는 데이터는 Redis에서 먼저 조회, 없으면 RDB에서 조회 후 캐싱
- **TTL 기반 휘발성 데이터**: 접속 상태(Presence)처럼 임시 데이터는 TTL 설정으로 자동 관리
- **비용 효율성**: 메모리 효율을 위해 최적화된 자료구조와 키 설계 (HASH, ZSET 적극 활용)

<details>
<summary><b>Redis Key 정보</b></summary>

```
1. 👥 채팅방별 유저 목록 - SET  
chat:room:members:{chatRoomCode} = {userId1, userId2, userId3, ...}  
→ 채팅방 참여자 목록 관리, 브로드캐스트 대상자 식별에 사용
```

```
2. 📦 유저별 채팅방 목록 - ZSET (Sorted Set)  
chat:rooms:{userId} = {chatRoomCode}  
score: {lastMessageAt} (timestamp millis)  
→ 사용자별 채팅방 목록 정렬(최신 메시지순), 채팅방 목록 조회 성능 최적화
```

```
3. 🧩 채팅방 메타데이터 - HASH  
chat:room:meta:{chatRoomCode} = 
{
  lastMessage: "어디서 만날까요?",
  lastMessageAt: "2024-04-11T22:30:00",
  lastMessageSeqId: "124"
}  
→ 채팅방 목록 미리보기 표시, 메시지 히스토리 요약 제공
```

```
4. 🧹 채팅방 메타 변경 감지 - SET  
dirty:chat:room:meta = "{chatRoomCode}"  
→ 배치 동기화를 위한 변경 감지용 키 저장소
```

```
5. 🔁 유저별 마지막 읽은 메시지 시퀀스 - STRING  
chat:room:last-read:{chatRoomCode}:{userId} = {lastReadSeqId}  
→ 접속 시 전체 읽음 처리 또는 메시지 읽을 때마다 갱신
```

```
6. 🧹 마지막 읽음 시퀀스 변경 감지 - SET  
dirty:chat:room:last-read = "{chatRoomCode}:{userId}"  
→ 배치 동기화를 위한 변경 감지용 키 저장소
```

```
7. 🟢 유저 접속 상태 - STRING  
chat:presence:{chatRoomCode}:{userId} = {serverId}  
→ TTL: 180초, 현재 접속한 서버의 위치 기반 라우팅 (WebSocket 유니캐스트용)
```

```
8. 🧩 세션 ID → 유저 ID 매핑 - HASH  
chat:session:{sessionId} = 
{
  userId: {userId},
  chatRoomCode: {chatRoomCode}
}  
→ TTL: 180초, Presence TTL 갱신/확인용 역참조 세션 저장소
```

```
9. 🔢 채팅방 메시지 시퀀스 - STRING  
chat:room:seq:{chatRoomCode} = {lastSeqId}  
→ Redis INCR 기반 메시지 순번 관리, 채팅 메시지 정렬 및 읽음 판별 기준
```

</details>

<br>

### 2️⃣ 트래픽 특성에 맞는 저장소 설계

채팅 서비스는 데이터 특성과 트래픽 패턴에 따라 최적화된 다중 저장소 아키텍처를 채택했습니다.

#### 저장소 분리와 역할

- **MongoDB**: 채팅 메시지 저장에 최적화
    - read/write 비율이 1:1에 가까운 빈번한 쓰기 작업 특성 고려
    - 유연한 스키마로 메시지 콘텐츠 및 메타데이터 통합 관리
    - 인덱싱을 통한 효율적인 채팅 히스토리 조회 지원: 채팅방별 SeqId를 복합 인덱스로 설정해서 조회 성능 향상
- **RDB (관계형 데이터베이스)**: 구조화된 메타 데이터 관리
    - 채팅방, 채팅 참가자 등 비즈니스 핵심 엔티티 관리
    - 백엔드 API 서버와 공유하여 시스템 통합성 유지
- **Redis**: 실시간 상태 및 빈번히 변경되는 데이터 관리
    - 채팅 메시지 발행 시 변경되는 메타데이터 고속 처리
    - 채팅방 목록 정렬, 읽음 상태, 접속 상태 등 실시간 데이터 관리

#### 데이터 서비스 계층화

- **`RedisService` 추상화**: 데이터 접근 로직 캡슐화
    - 키 존재 여부 자동 검증
    - Redis에 데이터가 없을 경우 RDB 조회 로직 통합
    - 일관된 데이터 액세스 패턴 제공

<br>

### 3️⃣ RDB와의 일관성 유지 (Eventual Consistency)

Redis와 RDB 간의 데이터 일관성은 최종 일관성(Eventual Consistency) 모델을 통해 효율적으로 관리합니다.

#### 동기화 패턴

- **Dirty 키 기반 변경 감지**:
    - 데이터 변경 시 해당 키를 Redis의 Dirty 저장소에 기록
    - `dirty:chat:room:meta`, `dirty:chat:room:last-read` 등의 저장소에 변경된 키 ID 추적
- **배치 기반 효율적 동기화**:
    - 스케줄러를 통한 주기적 배치 동기화
    - **청크 단위** 처리로 백엔드 API 서버 부하 분산
    - **JDBC 배치를** 활용한 일괄 업데이트로 DB 효율성 확보

#### 동기화 파이프라인

1. **변경 감지**: Redis SET(dirty:*)에 변경된 키 ID 저장
2. **주기적 스캔**: 스케줄러가 주기적으로 dirty 키 집합 스캔
3. **배치 추출**: 스캔된 키를 설정된 청크 크기로 추출
4. **RDB 업데이트**: 추출된 데이터를 백엔드 API 서버로 전송하여 영구 저장소에 일괄 업데이트(JDBC Batch Update)
5. **추적 키 제거**: 성공적으로 처리된 키는 dirty 집합에서 제거

<br>

### 4️⃣ 데이터 정합성 보장 메커니즘

#### 시퀀스 기반 일관성

- **Redis INCR 기반 메시지 순번**:
    - 채팅방별 단조 증가하는 시퀀스 ID로 메시지 순서 보장
    - 시퀀스 ID를 기준으로 읽음 상태 추적 및 미읽음 메시지 카운트 계산

#### 이벤트 기반 데이터 전파

- **이벤트 스트리밍을 통한 일관성**:
    - 데이터 변경 시 Kafka 이벤트 발행으로 여러 저장소 간 동기화
    - 멱등적 처리로 중복 이벤트에도 데이터 일관성 유지

#### 장애 대응 전략

- **회복 메커니즘**:
    - Redis 장애 시 RDB에서 핵심 데이터 복구 가능
    - `RedisService` 계층의 자동 폴백으로 서비스 연속성 보장

<br>

## 🏗️ 시스템 구성도

<img width="1000" alt="Image" src="https://github.com/user-attachments/assets/74539432-4829-4d14-82c5-ca1f37e83c37" />

<br>
<br>

## 🗂 프로젝트 구조

```
├───📂client                           # 외부 서비스 클라이언트
├───📂common                           # 공통 유틸리티 및 응답 형식
│   ├───📂exception                    # 예외 처리 및 에러 코드
│   ├───📂response                     # API 응답 객체 (ApiResponse, ErrorResponse 등)
│   └───📂util                         # 유틸리티 클래스 (RedisKeyUtil 등)
├───📂config                           # 애플리케이션 설정
├───📂controller                       # API 컨트롤러
│   ├───📂external                     # 외부 API 엔드포인트 (REST API)
│   ├───📂internal                     # 내부 API 엔드포인트 (서비스 간 통신)
│   └───📂websocket                    # 웹소켓 핸들러
├───📂dto                              # 데이터 전송 객체
├───📂event                            # 이벤트 관련 객체
├───📂kafka                            # Kafka 관련 컴포넌트
│   ├───📂consumer                     # Kafka 컨슈머
│   └───📂producer                     # Kafka 프로듀서
├───📂model                            # 도메인 모델 및 엔티티
├───📂redis                            # Redis 관련 컴포넌트
├───📂repository                       # 데이터 접근 계층
├───📂scheduler                        # 정기적 작업 처리
└───📂service                          # 비즈니스 로직
```