# 순수웨딩 2.0

> 순수웨딩 채팅 서비스

### 목차

1. [프로젝트 소개](#-프로젝트-소개)
2. [시연 영상](#-시연-영상)
3. [이벤트 기반 채팅 시스템 아키텍처](#%EF%B8%8F-이벤트-기반-채팅-시스템-아키텍처)
4. [데이터 저장소 관리 전략](#-데이터-저장소-관리-전략)
5. [시스템 구성도](#%EF%B8%8F-시스템-구성도)
6. [프로젝트 구조](#-프로젝트-구조)

<br>

## 🚀 프로젝트 소개

순수웨딩 채팅 서비스는 STOMP 프로토콜과 Kafka 기반의 이벤트 스트리밍을 통해 **확장 가능하고 안정적인 실시간 메시지 전송**을 구현하였으며, **데이터 특성에 맞는 삼중 저장소 아키텍처**를 통해 실시간
응답성과 데이터 영구 보존을 모두 확보했습니다.

- **STOMP**: 실시간 양방향 통신 구현
- **Kafka**: 안정적인 메시지 브로커, 비동기 이벤트 처리
- **Redis**: 사용자 세션, 접속 상태, 읽음 상태 등 빈번히 변경되는 메타데이터 고속 처리
- **MongoDB**: 유연한 스키마로 채팅 메시지 영구 저장 및 효율적인 조회
- **관계형 DB**: 채팅방, 참여자 정보 등 구조화된 데이터 영구 저장 및 트랜잭션 관리

<br>

### 🗓 개발 기간

2025.03 ~ 2025.04

<br>

### 🔗 링크 모음

- **서비스 배포 주소**: `https://sunsu-wedding.shop` (서비스 중단)
- **프론트엔드 레포지토리**: [순수웨딩 프론트엔드 레포지토리 바로가기](https://github.com/kimchanho97/sunsuwedding_FE)
- **백엔드 API 서버 레포지토리**: [순수웨딩 메인 API 서버 레포지토리 바로가기](https://github.com/kimchanho97/sunsuwedding_BE)
- **프로젝트 문서(Notion)**: [순수웨딩 프로젝트 문서 바로가기](https://kimchanho.notion.site/2-0-1a0a1b1b0041809f8f31fa9314b10a34)

> **현재 서비스는 비용 절약을 위해 중단된 상태입니다.**  
> **프로젝트의 모든 상세 내용은 아래 문서에서 확인할 수 있습니다.**

<br>

## 🎥 시연 영상

#### ⚡️ 주요 기능

- 텍스트 및 이미지 실시간 전송
- 메시지 읽음 상태 동기화
- 사용자 온라인/오프라인 상태 표시
- 최근 메시지 기준 채팅방 목록 정렬
- 읽지 않은 메시지 수 표시

![Image](https://github.com/user-attachments/assets/7b804bca-c3da-4618-8d49-89464160a0b2)

<br>
<br>

## ✉️ 이벤트 기반 채팅 시스템 아키텍처

### 📌 유니캐스트 메시지 라우팅 설계

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/7b7bef96-fee3-4c35-9f7e-e23426e922e5" />

채팅 시스템은 확장성과 성능 최적화를 위해 유니캐스트 방식의 메시지 전송 구조를 채택했습니다.   
이는 기존 그물망(메시 토폴로지) 방식에서 발생하는 서버 간 과도한 연결 복잡성과 스케일 아웃 시 높은 구성 비용 문제를 해결합니다.

#### 핵심 설계: 독립적인 메시지 전송 계층

- **책임 분리**: 채팅 서버와 메시지 전송 로직이 독립된 서버로 분리
- **중앙화된 의존성**: 메시지 전송 서버만이 채팅 서버들과의 연결 관리
- **단방향 의존성**: 채팅 서버는 Kafka 브로커에만 의존하여 결합도 최소화
- **위치 기반 라우팅**: Redis에 저장된 사용자별 서버 위치 정보로 정확한 메시지 전달

#### 확장성 확보

- **스타형 토폴로지**: 채팅 서버 간 직접 연결 없이 중앙 집중식 구조 유지
- **간소화된 인프라**: 새 서버 추가 시 복잡한 네트워크 설정 변경 불필요
- **비대칭 스케일링**: 채팅 서버와 메시지 전송 서버의 인스턴스 수를 독립적으로 조정 가능

#### 메시지 전송 프로세스

1. 클라이언트 메시지 → 채팅방 참여자 조회 → Kafka 이벤트 발행
2. 메시지 전송 서버에서 이벤트 소비
3. Redis에서 대상 사용자의 서버 위치 조회
4. 해당 서버로만 메시지 전달

브로드캐스트 방식과 달리 유니캐스트는 필요한 서버에만 메시지를 전달하여 네트워크 트래픽과 서버 부하를 최소화합니다.

> **참고**: 현재는 인프라 관리 효율성을 고려해 별도 메시지 전송 서버 대신 채팅 서버 내부에 컨슈머 로직을 통합 구현했습니다.

<br>

### 📌 비동기 이벤트 처리 파이프라인

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/f0f31eb6-677c-4c47-8605-91b43ca1111d" />

메시지 처리의 각 단계를 독립적인 이벤트로 분리하여 시스템의 확장성과 안정성을 확보했습니다:

1. **메시지 수신 및 요청 이벤트 발행**: 클라이언트 메시지 → `chat-message` 토픽 이벤트 발행
2. **영구 저장 처리**: 메시지 시퀀스 할당 → MongoDB 저장 → `chat-message-saved` 토픽 이벤트 발행
3. **후속 병렬 처리**:
    - 읽음 상태 동기화: 온라인 사용자의 읽음 상태 업데이트
    - 메시지 전달: 온라인 사용자 서버로 유니캐스트 메시지 전송
    - 채팅방 정렬: 참여자별 채팅방 목록 정렬 업데이트

이 비동기 파이프라인 구조는 각 단계의 독립적 확장을 가능하게 하며, 메시지 처리 성능을 최적화합니다.

<br>

### 📌 메시지 전달 신뢰도 보장 메커니즘

<img width="700" alt="Image" src="https://github.com/user-attachments/assets/39cfc226-3e1e-4e4c-bfe6-e4b5ea16d892" />

채팅 서비스는 데이터 일관성과 메시지 유실 방지를 위해 두 가지 수준의 신뢰성을 구현했습니다.

#### 기본 신뢰성 보장 (At-least-once)

채팅 서비스의 모든 이벤트 처리는 **최소 한 번 전달(at-least-once delivery)** 방식으로 설계되어 메시지 유실을 방지합니다.

- **프로듀서 측 구현**
    - `acks=all` 설정으로 모든 레플리카 확인 후 응답
    - 멱등 프로듀서(`enable.idempotence=true`) 설정으로 중복 전송 방지
- **컨슈머 측 구현**
    - 명시적 수동 확인(Manual Acknowledgment) 방식 채택
    - 처리 완료 후에만 오프셋 커밋하여 메시지 유실 방지
    - 멱등적 처리 로직으로 중복 처리 방지

#### 중요 경로의 정확히 한 번 전달 (Exactly-once)

추가 서비스 연동 시 확장성을 고려하여, 채팅 메시지가 MongoDB에 저장된 후 발행되는 이벤트(`chat-message` → `chat-message-saved`)에서는 **정확히 한 번 전달(
exactly-once delivery)을** 보장해 데이터 일관성을 유지합니다.

- **Kafka 트랜잭션 처리**
    - 트랜잭션 프로듀서 및 컨슈머 사용
    - 이벤트 발행과 오프셋 커밋의 원자성 보장
    - 격리 수준 `read_committed` 설정으로 커밋된 메시지만 소비
- **MongoDB 멱등성**
    - MongoDB에서 메시지 ID(`_id`) 기반 upsert 연산으로 멱등성 보장
    - `findAndModify` 연산으로 저장과 조회를 단일 원자적 작업으로 처리

<br>

## 💾 데이터 저장소 관리 전략

채팅 서비스는 대규모 실시간 트래픽을 안정적으로 처리하기 위해, 데이터의 특성과 워크로드에 따라 역할을 분담하는 다중 저장소(Polyglot Persistence) 아키텍처를 채택했습니다.

### 1️⃣ 저장소 역할 정의: Primary Store와 System of Record

각 저장소는 명확한 역할과 책임을 가집니다. 특히 실시간 데이터 처리는 Redis가, 데이터의 영구 보관은 RDB가 책임지는 구조입니다.

* **Redis (실시간 데이터의 주 저장소 - Primary Store)**
    * **역할**: 읽음 상태, 채팅방 목록 정렬, 마지막 메시지 등 사용자에게 즉각적인 피드백이 필요한 모든 데이터를 처리하는 **실시간 시스템의 신뢰의 원천(Source of Truth)** 입니다.
    * **전략**: 인메모리 저장소의 빠른 속도와 `ZSET`, `HASH` 등 효율적인 자료구조를 활용하여 성능을 극대화합니다.

    <details>
    <summary><b>Key 정보</b></summary>

    ```
    1. 👥 채팅방별 유저 목록 - SET  
    chat:room:members:{chatRoomCode} = {userId1, userId2, userId3, ...}  
    → 채팅방 참여자 목록 관리, 브로드캐스트 대상자 식별에 사용
    ```

    ```
    2. 📦 유저별 채팅방 목록 - ZSET (Sorted Set)  
    chat:rooms:{userId} = {chatRoomCode}  
    score: {lastMessageAt} (timestamp millis)  
    → 사용자별 채팅방 목록 정렬(최신 메시지순), 채팅방 목록 조회 성능 최적화
    ```

    ```
    3. 🧩 채팅방 메타데이터 - HASH  
    chat:room:meta:{chatRoomCode} = 
    {
      lastMessage: "어디서 만날까요?",
      lastMessageAt: "2024-04-11T22:30:00",
      lastMessageSeqId: "124"
    }  
    → 채팅방 목록 미리보기 표시, 메시지 히스토리 요약 제공
    ```

    ```
    4. 🧹 채팅방 메타 변경 감지 - SET  
    dirty:chat:room:meta = "{chatRoomCode}"  
    → 배치 동기화를 위한 변경 감지용 키 저장소
    ```

    ```
    5. 🔁 유저별 마지막 읽은 메시지 시퀀스 - STRING  
    chat:room:last-read:{chatRoomCode}:{userId} = {lastReadSeqId}  
    → 접속 시 전체 읽음 처리 또는 메시지 읽을 때마다 갱신
    ```

    ```
    6. 🧹 마지막 읽음 시퀀스 변경 감지 - SET  
    dirty:chat:room:last-read = "{chatRoomCode}:{userId}"  
    → 배치 동기화를 위한 변경 감지용 키 저장소
    ```

    ```
    7. 🟢 유저 접속 상태 - STRING  
    chat:presence:{chatRoomCode}:{userId} = {serverId}  
    → TTL: 180초, 현재 접속한 서버의 위치 기반 라우팅 (WebSocket 유니캐스트용)
    ```

    ```
    8. 🧩 세션 ID → 유저 ID 매핑 - HASH  
    chat:session:{sessionId} = 
    {
      userId: {userId},
      chatRoomCode: {chatRoomCode}
    }  
    → TTL: 180초, Presence TTL 갱신/확인용 역참조 세션 저장소
    ```

    ```
    9. 🔢 채팅방 메시지 시퀀스 - STRING  
    chat:room:seq:{chatRoomCode} = {lastSeqId}  
    → Redis INCR 기반 메시지 순번 관리, 채팅 메시지 정렬 및 읽음 판별 기준
    ```

    </details>

* **RDB (영구 데이터 기록 시스템 - System of Record)**
    * **역할**: 채팅방, 참여자 정보 등 **데이터 무결성이 중요한 핵심 비즈니스 엔티티를 영구적으로 보관**하는 최종 기록 시스템입니다.
    * **전략**: `ACID` 트랜잭션을 통해 데이터의 정합성을 보장하고, 장애 시 Redis를 복구할 수 있는 원천 데이터의 역할을 합니다.

* **MongoDB (메시지 본문 아카이브)**
    * **역할**: 읽기/쓰기가 빈번하고 비정형적인 대용량 메시지 본문을 저장하고 조회하는 역할을 담당합니다.
    * **전략**: 유연한 스키마와 `채팅방ID-시퀀스ID` 복합 인덱스를 통해 대용량 메시지 트래픽을 효율적으로 처리합니다.

<br>

### 2️⃣ 아키텍처 패턴: 성능과 안정성을 위한 전략

Redis를 Primary Store로 사용하는 아키텍처를 기반으로, 다음과 같은 패턴을 조합하여 성능과 안정성을 확보했습니다.

* **Write-Back (쓰기 지연 및 성능 최적화)**
    * RDB에 동기적으로 쓰기에는 부담이 큰 데이터는 Redis에 먼저 기록하여 사용자에게 즉시 피드백합니다. RDB 동기화는 비동기 파이프라인으로 분리하여 DB 쓰기 지연이 사용자 경험에 영향을 미치는 것을
      원천 차단합니다.

* **Cache-Aside (데이터 복구를 위한 방어선)**
    * Redis 장애나 데이터 유실 시, **최종 기록 시스템인 RDB에서 데이터를 읽어와 Redis를 복구(Hydration)**하는 방어선을 구축하여 데이터 안정성을 보강합니다.

* **Ephemeral Data Handling (휘발성 데이터 단독 처리)**
    * 사용자의 접속 상태처럼 영구 보관이 불필요한 데이터는 Redis에서만 `TTL`을 설정하여 독립적으로 처리함으로써 시스템 복잡도를 낮춥니다.

<br>

### 3️⃣ 최종 일관성 보장: 'Dirty Set' 동기화 파이프라인

Redis와 RDB 간의 데이터 일관성은 **'Dirty Set' 패턴**과 스케줄러를 이용한 비동기 배치 파이프라인으로 구현하여, 최종 일관성을 보장합니다.

* **변경분 기록 (Mark as Dirty)**
    * Redis 데이터 변경 시, 변경된 데이터의 키를 별도의 `Set` 자료구조(예: `dirty:chat:room:meta`)에 추가하여 '변경되었음'을 표시합니다.

* **비동기 일괄 처리 (Batch Update)**
    * 스케줄러(3분 간격)가 `dirty` Set을 스캔하여 키를 수집하고, **JDBC Batch Update**를 통해 RDB에 효율적으로 동기화합니다.

* **자동 재시도 메커니즘**
    * DB 장애 등으로 동기화에 실패하면 키를 `dirty` Set에서 제거하지 않고 남겨둡니다. 실패한 데이터는 다음 주기에 **자동으로 재시도**되어 최종 일관성을 100% 보장합니다.

<br>

### 4️⃣ 데이터 정합성 및 장애 복구 전략

* **메시지 순서 보장**
    * 채팅방별 **Redis `INCR`** 명령어를 통해 원자적이고 단조롭게 증가하는 시퀀스를 발급하여, 모든 메시지의 순서를 보장합니다.

* **이벤트 기반 상태 전파**
    * **Kafka**를 통해 메시지 저장 후 후속 처리가 필요한 이벤트를 발행합니다. 각 시스템은 이벤트를 구독하여 필요한 상태를 동기화하며, 멱등성을 보장하여 중복 처리 문제를 방지합니다.

* **장애 허용을 위한 서비스 계층화**
    * **`RedisService` 계층에서 데이터 접근 로직을 캡슐화**합니다. 이 계층은 Redis 조회 실패 시 RDB를 자동으로 조회하는 **폴백(Fallback) 로직을 포함**하고 있습니다. 이는
      2번 항목의 `Cache-Aside` 복구 전략의 구체적인 구현체로서, 서비스의 중단 없는 연속성을 보장합니다.

<br>

## 🏗️ 시스템 구성도

<img width="1000" alt="Image" src="https://github.com/user-attachments/assets/74539432-4829-4d14-82c5-ca1f37e83c37" />

<br>
<br>

## 🗂 프로젝트 구조

```
├───📂client                           # 외부 서비스 클라이언트
├───📂common                           # 공통 유틸리티 및 응답 형식
│   ├───📂exception                    # 예외 처리 및 에러 코드
│   ├───📂response                     # API 응답 객체 (ApiResponse, ErrorResponse 등)
│   └───📂util                         # 유틸리티 클래스 (RedisKeyUtil 등)
├───📂config                           # 애플리케이션 설정
├───📂controller                       # API 컨트롤러
│   ├───📂external                     # 외부 API 엔드포인트 (REST API)
│   ├───📂internal                     # 내부 API 엔드포인트 (서비스 간 통신)
│   └───📂websocket                    # 웹소켓 핸들러
├───📂dto                              # 데이터 전송 객체
├───📂event                            # 이벤트 관련 객체
├───📂kafka                            # Kafka 관련 컴포넌트
│   ├───📂consumer                     # Kafka 컨슈머
│   └───📂producer                     # Kafka 프로듀서
├───📂model                            # 도메인 모델 및 엔티티
├───📂redis                            # Redis 관련 컴포넌트
├───📂repository                       # 데이터 접근 계층
├───📂scheduler                        # 정기적 작업 처리
└───📂service                          # 비즈니스 로직
```